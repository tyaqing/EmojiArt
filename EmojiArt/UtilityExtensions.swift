//
//  UtilityExtensions.swift
//  LectureEmojiArt
//
//  Created by sun on 2021/10/20.
//

import SwiftUI

extension Collection where Element: Identifiable {
	func index(matching element: Element) -> Self.Index? {
		firstIndex(where: { $0.id == element.id })
	}
}

extension Character {
	var isEmoji: Bool {
		// Swift does not have a way to ask if a Character isEmoji
		// but it does let us check to see if our component scalars isEmoji
		// unfortunately unicode allows certain scalars (like 1)
		// to be modified by another scalar to become emoji (e.g. 1️⃣)
		// so the scalar "1" will report isEmoji = true
		// so we can't just check to see if the first scalar isEmoji
		// the quick and dirty here is to see if the scalar is at least the first true emoji we know of
		// (the start of the "miscellaneous items" section)
		// or check to see if this is a multiple scalar unicode sequence
		// (e.g. a 1 with a unicode modifier to force it to be presented as emoji 1️⃣)
		if let firstScalar = unicodeScalars.first, firstScalar.properties.isEmoji {
			return firstScalar.value >= 0x238d || unicodeScalars.count > 1
		} else {
			return false
		}
	}
}

extension CGRect {
	var center: CGPoint {
		CGPoint(x: midX, y: midY)
	}
}

// convenience functions for [NSItemProvider] (i.e. array of NSItemProvider)
// makes the code for  loading objects from the providers a bit simpler
// NSItemProvider is a holdover from the Objective-C (i.e. pre-Swift) world
// you can tell by its very name (starts with NS)
// so unfortunately, dealing with this API is a little bit crufty
// thus I recommend you just accept that these loadObjects functions will work and move on
// it's a rare case where trying to dive in and understand what's going on here
// would probably not be a very efficient use of your time
// (though I'm certainly not going to say you shouldn't!)
// (just trying to help you optimize your valuable time this quarter)

extension Array where Element == NSItemProvider {
	func loadObjects<T>(ofType theType: T.Type, firstOnly: Bool = false, using load: @escaping (T) -> Void) -> Bool where T: NSItemProviderReading {
		if let provider = first(where: { $0.canLoadObject(ofClass: theType) }) {
			provider.loadObject(ofClass: theType) { object, _ in
				if let value = object as? T {
					DispatchQueue.main.async {
						load(value)
					}
				}
			}
			return true
		}
		return false
	}

	func loadObjects<T>(ofType theType: T.Type, firstOnly: Bool = false, using load: @escaping (T) -> Void) -> Bool where T: _ObjectiveCBridgeable, T._ObjectiveCType: NSItemProviderReading {
		if let provider = first(where: { $0.canLoadObject(ofClass: theType) }) {
			let _ = provider.loadObject(ofClass: theType) { object, _ in
				if let value = object {
					DispatchQueue.main.async {
						load(value)
					}
				}
			}
			return true
		}
		return false
	}

	func loadFirstObject<T>(ofType theType: T.Type, using load: @escaping (T) -> Void) -> Bool where T: NSItemProviderReading {
		loadObjects(ofType: theType, firstOnly: true, using: load)
	}

	func loadFirstObject<T>(ofType theType: T.Type, using load: @escaping (T) -> Void) -> Bool where T: _ObjectiveCBridgeable, T._ObjectiveCType: NSItemProviderReading {
		loadObjects(ofType: theType, firstOnly: true, using: load)
	}
}
